#!/bin/python3
from datetime import datetime, timedelta
from subprocess import Popen, PIPE
import alsaaudio
import glob
import psutil
import re
import threading
import time
import mpd
import math
import os

fonts = [
    ['terminesspowerline:size=8', -1],
    ['Font Awesome:pixelsize=14', 0],
    ['DejaVu Sans:pixelsize=11', -1],
    ['DejaVu Sans:pixelsize=12', -1],
]
height                     = 19
default_background_color   = '#c0000000'
default_font_color         = '#dddddd'
inactive_text_color        = '#666666'
active_progressbar_color   = '#d0bbbbbb'
inactive_progressbar_color = '#d0888888'
workspaces_background      = '#c0333333'
active_workspace_color     = '#dddddd'
inactive_workspace_color   = '#888888'
clock_background_color     = '#c0333333'
clock_text_color           = 'white'
interval                   = 1

class Data(object):
    def __init__(self):
        self.cpu = 0
        self.volume = 0
        self.time = datetime.now()
        self.mpd_status = None
        self.current_song = None
        self.monitors = []
        self.battery_present = False
        self.battery_percent = 0
        self.battery_discharging = False
        self.network_enabled = False
        self.network_traffic_received = 0
        self.network_traffic_sent = 0

class Monitor(object):
    LAYOUT_TILED = 1
    LAYOUT_MONOCLE = 2

    def __init__(self):
        self.name = None
        self.focused = False
        self.workspaces = []
        self.layout = None

class Workspace(object):
    def __init__(self):
        self.name = None
        self.focused = False
        self.free = True
        self.urgent = False


class Renderer(object):
    ALIGN_LEFT = 'l'
    ALIGN_CENTER = 'c'
    ALIGN_RIGHT = 'r'

    def __init__(self):
        self.__properties = {}
        self.__setters = {
            'background_color': (lambda value: '%%{B%s}' % value, 'black'),
            'font_color':       (lambda value: '%%{F%s}' % value, 'white'),
            'font':             (lambda value: '%%{T%d}' % value, 1),
            'current_monitor':  (lambda value: '%%{S%d}' % value, 1),
            'alignment':        (lambda value: '%%{%s}' % value, self.ALIGN_LEFT),
        }
        self.clear()

    def __getattr__(self, name):
        if name in self.__setters:
            if name in self.__properties:
                return self.__properties[name]
            return None
        return object.__getattribute__(self, name)

    def __setattr__(self, name, value):
        if name.startswith('_'):
            return super(Renderer, self).__setattr__(name, value)
        if not name in self.__setters:
            raise AttributeError
        if name not in self.__properties or self.__properties[name] != value:
            self.print(self.__setters[name][0](value))
            self.__properties[name] = value

    def clear(self):
        self._text = ''
        for k, v in self.__setters.items():
            self.__setattr__(k, v[1])

    @property
    def text(self):
        return self._text

    def print(self, text):
        self._text += text

    def temporary(self):
        return self.Temporary(self)

    def clickable(self, button, command):
        return self.Clickable(self, button, command)

    class Temporary(object):
        def __init__(self, renderer):
            self.renderer = renderer
        def __enter__(self):
            self.font = self.renderer.font
            self.font_color = self.renderer.font_color
            self.background_color = self.renderer.background_color
        def __exit__(self, *args):
            self.renderer.font = self.font
            self.renderer.font_color = self.font_color
            self.renderer.background_color = self.background_color

    class Clickable(object):
        def __init__(self, renderer, button, command):
            self.renderer = renderer
            self.button = button
            self.command = command
        def __enter__(self):
            self.renderer.print('%%{A%d:%s:}' % (self.button, self.command.replace(':', '\:')))
        def __exit__(self, *args):
            self.renderer.print('%{A}')


class MyRenderer(object):
    def __init__(self, data):
        self.current_margin = 0
        self.renderer = Renderer()
        self.data = data

        command = ['lemonbar', '-gx' + str(height)]
        for font in fonts:
            command += ['-f', font[0], '-o', str(font[1])]
        sh_process = Popen('sh', stdin=PIPE)
        self.lemonbar_process = Popen(command, stdout=sh_process.stdin, stdin=PIPE)

    def print_text(self, text):
        self.renderer.print(text)
        self.current_margin = 0

    def ensure_margin(self, margin): #margin = 1/3 em space
        if margin > self.current_margin:
            with self.renderer.temporary():
                self.renderer.font = 2
                self.renderer.print('\u2004' * (margin - self.current_margin))
            self.current_margin = margin

    def print_seconds(self, seconds):
        seconds = math.floor(float(seconds))
        self.print_text('%02d:%02d' % (seconds // 60, seconds % 60))

    def print_icon(self, text, margin=3):
        with self.renderer.temporary():
            self.renderer.font = 2
            self.ensure_margin(margin)
            self.print_text(text)
            self.ensure_margin(margin)

    def render_progressbar(self, number, width=15):
        filled = int(number * width / 100.)
        with self.renderer.temporary():
            self.renderer.font = 3
            self.renderer.font_color = active_progressbar_color
            self.print_text('\u2588' * filled)
            self.renderer.font_color = inactive_progressbar_color
            self.print_text('\u2588' * (width - filled))

    def render_workspaces(self, monitor):
        with self.renderer.temporary(), \
             self.renderer.clickable(5, 'bspc monitor -f %s;bspc desktop -f prev' % monitor.name), \
             self.renderer.clickable(4, 'bspc monitor -f %s;bspc desktop -f next' % monitor.name):
            self.renderer.background_color = workspaces_background
            self.renderer.font = 4
            self.ensure_margin(2)
            for workspace in monitor.workspaces:
                with self.renderer.clickable(1, 'bspc monitor -f %s;bspc desktop -f %s' % (monitor.name, workspace.name)):
                    if workspace.focused:
                        self.renderer.font_color = active_workspace_color
                    else:
                        self.renderer.font_color = inactive_workspace_color
                    if workspace.free:
                        self.print_text('\u25a1')
                    else:
                        self.print_text('\u25a0')
                self.ensure_margin(1)
            self.ensure_margin(2)
            self.print_text('') #hack - trigger margin reset due to background change

    def render_mpd_status(self):
        if not self.data.mpd_status:
            return

        with self.renderer.clickable(1, 'mpc toggle'):
            if 'state' in self.data.mpd_status and self.data.mpd_status['state'] == 'play':
                self.print_icon('\uf04b')
            else:
                self.print_icon('\uf04c')

            with self.renderer.clickable(4, 'mpc prev'), \
                 self.renderer.clickable(5, 'mpc next'):
                if self.data.current_song and 'artist' in self.data.current_song:
                    self.print_text(self.data.current_song['artist'])
                    self.print_text(' - ')
                    self.print_text(self.data.current_song['title'])
                else:
                    self.print_text('Stopped')
            self.ensure_margin(2)
            if 'elapsed' in self.data.mpd_status:
                self.print_seconds(self.data.mpd_status['elapsed'])
                self.print_text('/')
                self.print_seconds(self.data.current_song['time'])

        with self.renderer.clickable(1, 'mpc random'), \
             self.renderer.temporary():
            if 'random' not in self.data.mpd_status or self.data.mpd_status['random'] != '1':
                self.renderer.font_color = inactive_text_color
            self.print_icon('\uf074')

    def render_traffic(self):
        if self.data.network_enabled:
            self.print_icon('\uf019', margin=2)
            self.print_text('%03.0f' % (self.data.network_traffic_received / 1024.0))
            self.print_text('K')
            self.print_icon('\uf093', margin=2)
            self.print_text('%03.0f' % (self.data.network_traffic_sent / 1024.0))
            self.print_text('K')

    def render_battery(self):
        if self.data.battery_present:
            with self.renderer.temporary():
                if self.data.battery_discharging:
                    self.renderer.font_color = inactive_text_color
                self.print_icon('\uf1e6', margin=2)
            self.render_progressbar(self.data.battery_percent)

    def render_cpu_usage(self):
        with self.renderer.clickable(1, 'run-or-raise -n htop -p "urxvt -e htop"'):
            self.print_icon('\uf085', margin=2)
            self.render_progressbar(self.data.cpu)

    def render_volume(self):
        with self.renderer.clickable(1, 'run-or-raise -n alsamixer -p "urxvt -e alsamixer"'):
            self.print_icon('\uf028', margin=2)
            self.render_progressbar(self.data.volume)

    def render_date(self):
        self.ensure_margin(3)
        self.print_text(datetime.strftime(self.data.time, '%a, %b %d'))

    def render_clock(self):
        self.ensure_margin(2)
        self.renderer.background_color = clock_background_color
        self.renderer.font_color = clock_text_color
        self.print_text(datetime.strftime(self.data.time, '%H:%M:%S'))
        self.ensure_margin(2)

    def render(self):
        self.renderer.clear()
        for monitor_number, monitor in enumerate(self.data.monitors):
            self.current_margin = 0
            self.renderer.current_monitor = monitor_number
            self.renderer.background_color = default_background_color
            self.renderer.font_color = default_font_color

            self.renderer.alignment = Renderer.ALIGN_LEFT
            self.render_workspaces(monitor)
            self.render_mpd_status()

            self.renderer.alignment = Renderer.ALIGN_RIGHT
            self.render_traffic()
            self.render_battery()
            self.render_cpu_usage()
            self.render_volume()
            self.render_date()
            self.render_clock()

            self.renderer.background_color = default_background_color

        line = (self.renderer.text + "\n").encode('utf8')
        self.lemonbar_process.stdin.write(line)
        self.lemonbar_process.stdin.flush()


def refresh_cpu(data, render_func):
    while True:
        data.cpu = psutil.cpu_percent(interval=interval)

def refresh_song(data, render_func):
    client = mpd.MPDClient()
    client.connect(host='localhost', port=6600)
    while True:
        data.mpd_status = client.status()
        data.current_song = client.currentsong()
        time.sleep(interval)

def refresh_workspaces(data, render_func):
    bspc_process = Popen(['bspc', 'control', '--subscribe'], stdout=PIPE)
    while True:
        line = bspc_process.stdout.readline().decode('utf8').strip()
        line = re.sub('^W', '', line)
        if line == '':
            continue

        data.monitors = []
        current_monitor = None
        for item in line.split(':'):
            key, value = item[0], item[1:]

            if key in 'mM':
                current_monitor = Monitor()
                current_monitor.name = value
                current_monitor.focused = key.isupper()
                data.monitors.append(current_monitor)

            elif key in 'oOfFuU':
                workspace = Workspace()
                workspace.name = value
                workspace.focused = key.isupper()
                workspace.free = key in 'fF'
                workspace.urgent = key in 'uU'
                current_monitor.workspaces.append(workspace)

            elif key in 'lL':
                if value in 'mM':
                    current_monitor.layout = Monitor.LAYOUT_MONOCLE
                elif value in 'tT':
                    current_monitor.layout = Monitor.LAYOUT_TILED

        data.monitors.reverse() #hack...
        render_func()

def refresh_battery(data, render_func):
    try:
        charge_now = glob.glob('/sys/class/power_supply/*/charge_now')[0]
        charge_max = glob.glob('/sys/class/power_supply/*/charge_full')[0]
        charge_status = glob.glob('/sys/class/power_supply/*/status')[0]
        data.battery_present = True
    except IndexError:
        data.battery_present = False
    if data.battery_present:
        while True:
            with open(charge_now, 'r') as charge_now_fh, \
                 open(charge_max, 'r') as charge_max_fh, \
                 open(charge_status, 'r') as charge_status_fh:
                now = int(charge_now_fh.read())
                max = int(charge_max_fh.read())
                status = charge_status_fh.read().strip().lower()
                data.battery_discharging = status == 'discharging'
                data.battery_percent = now * 100.0 / max
                time.sleep(interval * 3)

def refresh_network(data, render_func):
    try:
        rx_path = None
        tx_path = None
        for interface in glob.glob('/sys/class/net/*'):
            with open(os.path.join(interface, 'operstate'), 'r') as fh:
                if fh.read().strip().lower() == 'up':
                    rx_path = os.path.join(interface, 'statistics', 'rx_bytes')
                    tx_path = os.path.join(interface, 'statistics', 'tx_bytes')
                    data.network_enabled = True
    except:
        data.network_enabled = False
    if data.network_enabled:
        with open(rx_path, 'r') as rx_fh, open(tx_path, 'r') as tx_fh:
            old_rx_bytes = int(rx_fh.read())
            old_tx_bytes = int(tx_fh.read())
        while True:
            with open(rx_path, 'r') as rx_fh, open(tx_path, 'r') as tx_fh:
                rx_bytes = int(rx_fh.read())
                tx_bytes = int(tx_fh.read())
                data.network_traffic_received = (rx_bytes - old_rx_bytes) / interval
                data.network_traffic_sent = (tx_bytes - old_tx_bytes) / interval
                old_rx_bytes = rx_bytes
                old_tx_bytes = tx_bytes
            time.sleep(interval)

def refresh_common(data, render_func):
    while True:
        data.time = datetime.now()
        data.volume = alsaaudio.Mixer().getvolume()[0]
        time.sleep(interval)

def main():
    data = Data()
    renderer = MyRenderer(data)

    threads = []
    for worker in [refresh_cpu, refresh_song, refresh_workspaces, refresh_network, refresh_battery, refresh_common]:
        thread = threading.Thread(target=worker, args=(data, renderer.render), daemon=True)
        threads.append(thread)
        thread.start()

    while True:
        renderer.render()
        time.sleep(interval)

if __name__ == '__main__':
    main()
