#!/bin/python3
from datetime import datetime, timedelta
from subprocess import Popen, PIPE
import alsaaudio
import psutil
import re
import sys
import threading
import time
import mpd
import math

fonts = \
[
    ['DejaVu Sans:size=9', 0],
    ['Font Awesome:size=10', 0],
    ['DejaVu Sans:pixelsize=11', -2],
]
shadow_color = '#507090'
inactive_color = '#707070'

class Data(object):
    def __init__(self):
        self.cpu = 0
        self.volume = 0
        self.time = datetime.now()
        self.mpd_status = None
        self.current_song = None
        self.monitors = []

class Monitor(object):
    LAYOUT_TILED = 1
    LAYOUT_MONOCLE = 2

    def __init__(self):
        self.name = None
        self.focused = False
        self.workspaces = []
        self.layout = None

class Workspace(object):
    def __init__(self):
        self.name = None
        self.focused = False
        self.free = True
        self.urgent = False



class Renderer(object):
    def __init__(self):
        self.font = self.font_color = self.background_color = None
        self.clear()

    def clear(self):
        self.text = ''
        self.set_font(1)
        self.set_font_color('white')
        self.set_background_color('black')

    def set_font_color(self, color):
        if color != self.font_color:
            self.print('%%{F%s}' % (color))
            self.font_color = color

    def get_font_color(self):
        return self.font_color

    def set_background_color(self, color):
        if color != self.background_color:
            self.print('%%{B%s}' % (color))
            self.background_color = color

    def get_background_color(self):
        return self.background_color

    def set_font(self, font):
        if font != self.font:
            self.print('%%{T%d}' % (font))
            self.font = font

    def get_font(self):
        return self.font

    def print(self, text):
        self.text += text

    def print_icon(self, text):
        with self.temporary():
            self.set_font(2)
            self.print_space(2)
            self.print(text)
            self.print_space(2)

    def print_number(self, text):
        match = re.match('^(0*(?!\.|$))(.*)$', text)
        with self.temporary():
            self.set_font_color(shadow_color)
            self.print(match.group(1))
        self.print(match.group(2))

    def print_space(self, number, force=False):
        if not re.match('.*[\s\u2000-\u200b](%{[^}]*})*$', self.text) or force:
            self.print('\u2004' * number) #number/3 em space

    def print_progressbar(self, number, width = 10):
        filled = int(number * width / 100.)
        with self.temporary():
            self.set_font(3)
            self.print('\u2588' * filled)
            self.set_font_color(inactive_color)
            self.print('â–ˆ' * (width - filled))

    def get_text(self):
        return self.text

    def switch_to_monitor(self, number):
        self.print('%%{S%d}' % number)

    def align_to_left(self):
        self.print('%{l}')

    def align_to_center(self):
        self.print('%{c}')

    def align_to_right(self):
        self.print('%{r}')

    def temporary(self):
        return self.Temporary(self)

    class Temporary(object):
        def __init__(self, renderer):
            self.renderer = renderer

        def __enter__(self):
            self.font = self.renderer.font
            self.font_color = self.renderer.font_color
            self.background_color = self.renderer.background_color

        def __exit__(self, *args):
            self.renderer.set_font(self.font)
            self.renderer.set_font_color(self.font_color)
            self.renderer.set_background_color(self.background_color)



class MyRenderer(object):
    def __init__(self, data):
        self.renderer = Renderer()
        self.data = data

        command = ['lemonbar', '-gx19']
        for font in fonts:
            command += ['-f', font[0], '-o', font[1]]
        command = [str(x) for x in command]
        sh_process = Popen('sh', stdin=PIPE)
        self.lemonbar_process = Popen(command, stdout=sh_process.stdin, stdin=PIPE)

    def print_seconds(self, seconds):
        seconds = math.floor(float(seconds))
        self.renderer.print('%02d:%02d' % (seconds // 60, seconds % 60))

    def print_workspaces(self, monitor):
        with self.renderer.temporary():
            self.renderer.set_background_color('#444444')
            self.renderer.print('%{A5:bspc monitor -f ' + monitor.name + ';bspc desktop -f prev;:}')
            self.renderer.print('%{A4:bspc monitor -f ' + monitor.name + ';bspc desktop -f next;:}')
            self.renderer.print_space(1, True)
            for workspace in monitor.workspaces:
                self.renderer.print('%{A:bspc monitor -f ' + monitor.name + ';bspc desktop -f ' + workspace.name + ':}')
                self.renderer.set_font(3)
                if workspace.focused:
                    self.renderer.set_font_color('#bbcccc')
                    self.renderer.print('\u25a0')
                else:
                    self.renderer.set_font_color('#667777')
                    self.renderer.print('\u25a0')
                self.renderer.print_space(1)
                self.renderer.print('%{A}')
            self.renderer.print_space(1, True)
            self.renderer.print('%{A}')
            self.renderer.print('%{A}')

    def print_mpd_status(self):
        if self.data.mpd_status:
            self.renderer.print(self.data.current_song['artist'])
            self.renderer.print(' - ')
            self.renderer.print(self.data.current_song['title'])
            self.renderer.print_space(3)
            if 'elapsed' in self.data.mpd_status:
                self.print_seconds(self.data.mpd_status['elapsed'])
                self.renderer.print('/')
                self.print_seconds(self.data.current_song['time'])

    def print_cpu_usage(self):
        #self.renderer.print_icon('\uf085')
        self.renderer.print_icon('\uf0e7')
        self.renderer.print_progressbar(self.data.cpu)

    def print_volume(self):
        self.renderer.print_icon('\uf028')
        self.renderer.print_progressbar(self.data.volume)

    def print_date(self):
        #self.renderer.print_icon('\uf073')
        #self.renderer.print_icon('\uf133')
        self.renderer.print_space(2)
        self.renderer.print(datetime.strftime(self.data.time, '%a, %b %d'))

    def print_clock(self):
        self.renderer.set_font_color('white')
        #self.renderer.print_icon('\uf017')
        self.renderer.print_space(2)
        self.renderer.print(datetime.strftime(self.data.time, '%H:%M:%S'))

    def render(self):
        self.renderer.clear()
        for monitor_number, monitor in enumerate(self.data.monitors):
            self.renderer.switch_to_monitor(monitor_number)
            self.renderer.set_background_color('black')
            self.renderer.set_font_color('#dddddd')
            self.renderer.align_to_left()
            self.print_workspaces(monitor)
            self.renderer.align_to_center()
            self.print_mpd_status()
            self.renderer.align_to_right()
            self.print_cpu_usage()
            self.print_volume()
            self.print_date()
            self.print_clock()
            self.renderer.print_space(2)
            self.renderer.set_background_color('black')

        line = (self.renderer.get_text() + "\n").encode('utf8')
        self.lemonbar_process.stdin.write(line)
        self.lemonbar_process.stdin.flush()



def refresh_cpu(data, render_func):
    while True:
        data.cpu = psutil.cpu_percent(interval=3)

def refresh_song(data, render_func):
    client = mpd.MPDClient()
    client.connect(host='localhost', port=6600)
    while True:
        data.mpd_status = client.status()
        data.current_song = client.currentsong()
        time.sleep(0.25)

def refresh_workspaces(data, render_func):
    command = ['bspc', 'control', '--subscribe']
    bspc_process = Popen(command, stdout=PIPE)
    while True:
        line = bspc_process.stdout.readline().decode('utf8').strip()
        if line.startswith('W'):
            line = line[1:]
        elif line == '':
            continue
        items = line.split(':')

        data.monitors = []
        current_monitor = None
        for item in items:
            key = item[0]
            value = item[1:]
            key_type = key.lower()

            if key_type == 'm':
                current_monitor = Monitor()
                current_monitor.name = value
                current_monitor.focused = key.isupper()
                data.monitors.append(current_monitor)

            elif key_type in 'ofu':
                workspace = Workspace()
                workspace.name = value
                workspace.focused = key.isupper()
                workspace.free = key_type == 'f'
                workspace.urgent = key_type == 'u'
                current_monitor.workspaces.append(workspace)

            elif key_type in 'l':
                if value == 'M':
                    current_monitor.layout = Monitor.LAYOUT_MONOCLE
                else:
                    current_monitor.layout = Monitor.LAYOUT_TILED

        data.monitors.reverse() #hack...
        render_func()

def refresh(data, render_func):
    while True:
        data.time = datetime.now()
        data.volume = alsaaudio.Mixer().getvolume()[0]
        time.sleep(1)

def main():
    data = Data()
    renderer = MyRenderer(data)

    threads = []
    for worker in [refresh_cpu, refresh_song, refresh_workspaces, refresh]:
        thread = threading.Thread(target=worker, args=(data, renderer.render))
        thread.daemon = True
        threads.append(thread)
        thread.start()

    while True:
        renderer.render()
        time.sleep(1)

if __name__ == '__main__':
    main()
